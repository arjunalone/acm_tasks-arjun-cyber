import gmpy2
from gmpy2 import mpz

# Given ciphertexts and moduli
ct1 = mpz('78406286729520927933597606356229817207730090348466337528850035686907731769583595879598630905387554797365268804265749503975166670245660278708562880234673953125')
ct2 = mpz('78406286729520927933597606356229817207730090348466337528850035686907731769583595879598630905387554797365268804265749503975166670245660278708562880234673953125')
ct3 = mpz('78406286729520927933597606356229817207730090348466337528850035686907731769583595879598630905387554797365268804265749503975166670245660278708562880234673953125')

n1 = mpz('93500162517048641546787096055793757535647246115573452820070426952722839105259206386726342320373080028589838409420934957286736144380948165832820988099621769638760228520922601557891245459269555695273287461982149159244732888497451549014876606240205619538734235283434466606740831016126239969278127395932813972501')
n2 = mpz('69389646088454519961777612972795170975757344514768971340015442739948594078401371455619333135568702919584689527569525412014628819453197654891812622405663009392306477333014587313114349970319506949532748028160803547659404882094671572233644067789871312676667284969540366763124836901936574299355649024020474292507')
n3 = mpz('173343492679580453099087472373077831318468581021117934856501363981932357178004338045575880395223727472909876082267313542279706329989182144352883996336740679533245920391761546352887945995038709117785508115723234046039796085997076590595344206748962306765136674210538263394651485897800900761481602355016363501601')

# Prepare the ciphertexts and moduli
ciphertexts = [ct1, ct2, ct3]
moduli = [n1, n2, n3]

# Step 1: Calculate N (product of all moduli)
N = 1
for n in moduli:
    N *= n

# Step 2: Apply the Chinese Remainder Theorem
m_cubed = 0
for i in range(len(moduli)):
    n_i = moduli[i]
    c_i = ciphertexts[i]
    N_i = N // n_i

    # Calculate the modular inverse of N_i modulo n_i
    x_i = gmpy2.invert(N_i, n_i)

    # Update m_cubed
    m_cubed += c_i * N_i * x_i

# Step 3: Reduce m_cubed modulo N
m_cubed = m_cubed % N

# Step 4: Compute the integer cube root to find m
m, exact = gmpy2.iroot(m_cubed, 3)

if exact:
    print("Cube root computed successfully.")
else:
    print("Cube root is not exact. Adjustments may be needed.")

# Convert the integer m to bytes
m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder='big')

# Decode the bytes to get the plaintext message
try:
    plaintext = m_bytes.decode('utf-8')
    print(m)
    print("Decrypted message:", plaintext)
except UnicodeDecodeError:
    print("Failed to decode the plaintext. It may not be in UTF-8 format.")
